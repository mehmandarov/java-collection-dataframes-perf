=== The Problem with in-memory architectures circa 2004

---

* Inherited an in-memory Java architecture that didn't fit in 32-bit memory space
** Large static in-memory domain object graph for Financial Services application
** Multiple calculated bi-directional/traversable in memory object graphs
** Millions of small `List`, `Set`, `Map` instances created with default sized arrays in memory
*** This resulted in a huge memory bloat
* Solution: Roll our own in-memory Java data structures
** Started with memory-efficient `FixedSized` `List`, `Set`, `Map` for small sizes
*** Java 9+ introduced similar memory-efficient immutable collections in JDK
** 64-bit JDK 1.4 release eventually gave some relief
*** Software problem (accessible memory) turned into hardware problem (available memory)
**** 32-bit memory bloat became bigger memory bloat on 64-bit with larger object references
*** https://www.baeldung.com/jvm-compressed-oops[Compressed OOPS] gave some relief for large heaps <32 gig and eventually <64 gig
**** Staying below these sizes required more tuning and optimizing of in-memory structures
** Roll our own memory-efficient mutable `Set` and `Map`
*** `UnifiedSet` not built out of `HashMap` like JDK `HashSet`
*** `UnifiedMap` does not store `Entry` objects and inlines keys and values in single array
**** Project Valhalla may result in similar inlining effect in JDK if `HashMap$Node` becomes a Value Class
** A complete complement of primitive collections was eventually added for `List`, `Set`, `Bag`, `Stack`, `Map`.
*** The fastest garbage to collect is the garbage (aka boxed primitives) you didn't generate
* Fast forward two decades to 2023
** All of these data structure memory optimizations are part of the open source https://github.com/eclipse/eclipse-collections[Eclipse Collections] library


link:toc.adoc[⬆️ TOC] /
link:./01_intro.adoc[⬅️ Intro] /
link:./02_01_the_problem_today.adoc[➡️ The problem today] 🥷
